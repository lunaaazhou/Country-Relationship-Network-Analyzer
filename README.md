# Country-Relationship-Network-Analyzer
Developed a graph-based analytics tool to map and analyze relationships between countries based on statistical data. Implemented adjacency queries, path detection, and relationship discovery, enabling insights into inter-country connections similar to social networks or recommendation systems.


Class Definition
In Project 5, I am still having the TimeSeries, TreeNode, Tree, and Node classes for managing individual country time series data, organize countries into a binary tree for efficient range queries, and support file operations via a hash table using double hashing—and add a new layer of graph classes to discover and represent relationships between countries. The new addings for this project 5 are the new Relationship struct, which encapsulates a tuple of (Series_Code, Threshold, Relation) and defines equality to ensure uniqueness—the GraphEdge class that holds a vector of Relationship objects and provides a method to add relationships without duplication the GraphNode class that represents a country with its name, code, and a vector of edges (each edge being a pair of a pointer to an adjacent GraphNode and its associated GraphEdge), and finally the Graph class itself, which, using a pointer to the Node object, initializes its GraphNodes from the hash table data and provides new commands such as INITIALIZE (to populate graph nodes), UPDATE_EDGES (which builds or silently updates the binary tree via buildInternal, uses findMatching to retrieve countries meeting a relationship condition, and then creates or updates edges between matching nodes), ADJACENT (to list all directly connected countries), PATH (to check connectivity via BFS), and RELATIONSHIPS (to display all relationship tuples on an edge), thereby integrating the binary tree search capabilities from Project 4 into a relational graph framework for discovering inter-country statistical relationships.

Alternatives and Justification
In Project 5, one alternative approach is to continuously using a linear scan of the hash table to compare country statistics and then build relationships directly from that data; However, that method would be less scalable as the dataset grows. Instead, I chose to use the binary tree which I previously built and used in Project 4 and Project3 for efficient range based queries to first identify groups of countries whose computed means satisfy given relationships (using functions like BUILD and FIND) and then represent these relationships in a relational graph. In this project 5 design, the hash table still provides fast O(1) direct lookups for loading and managing country data, while the binary tree enables efficient discovery of inter-country relationships. The graph layer, comprising the Relationship struct, GraphEdge, GraphNode, and Graph classes, encapsulates these relationships by storing unique relationship tuples on edges between country nodes, thus meeting both the performance and functionality requirements for dynamic relationship discovery and query operations such as ADJACENT, PATH, and RELATIONSHIPS.

Runtime Analysis
The runtime for my ADJACENT command is O(n), where n is the number of nodes (countries) in the graph. The function first iterates through the list of all nodes to find the one with the matching country code, which takes O(n) time in the worst case. Once the matching node is found, it either prints "none" if there are no adjacent nodes or iterates through the node’s adjacency list to print the names of connected countries. The number of adjacent nodes (edges) is at most n − 1, so this step is at most O(n) as well. Since these steps occur sequentially and the adjacency list traversal depends on the number of nodes, the overall worst-case runtime simplifies to O(n).
